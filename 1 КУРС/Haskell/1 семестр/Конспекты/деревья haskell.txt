Рассмотрим пример двоичного дерева, листья которого содержат значения произвольно-
го типа a, а вершины не содержат значений (т.е., рассмотрим вариант параметризованно-
го двоичного дерева):

data Tree a = Leaf a | Branch (Tree a) (Tree a)
deriving (Eq, Ord, Show, Read)



Определение конкретного дерева

Как вариант, мы могли бы создать параметризованное двоичное дерево, у которого каж-
дая вершина содержала бы значение типа a:

data ATree a = ALeaf a | ABranch (ATree a) a (ATree a) deriving (Eq, Ord, Show, Read)

*ATree a - ATree` – это название нового типа данных. Он параметризован, что означает, что он может использовать значения любого типа (означается `a`)

*

1. `Eq`:
   - Этот класс типов позволяет сравнивать значения на равенство с помощью оператора `(==)` и неравенства с помощью оператора `(/=)`.
   - Когда вы добавляете `deriving (Eq)`, Haskell автоматически генерирует реализацию для этих операторов на основе структуры вашего типа данных. Например, два дерева считаются равными, если их структура и значения всех узлов совпадают.

2. `Ord`:
   - Этот класс типов позволяет сравнивать значения на порядок с помощью операторов сравнения, таких как `<`, `>`, `<=`, `>=`.
   - `deriving (Ord)` автоматически предоставляет реализацию этих операторов, позволяя вам упорядочивать значения типа `ATree`. Процесс сравнения будет также основываться на структуре и значениях узлов дерева.

3. `Show`:
   - Этот класс типов позволяет конвертировать значения в строковое представление, что полезно для отладки и отображения.
   - `deriving (Show)` генерирует функцию `show`, которая преобразует значения типа `ATree` в строку. Это упрощает вывод данных на экран и позволяет использовать оператор `print` для вашего типа данных.

4. `Read`:
   - Этот класс типов позволяет парсить строку в значение вашего типа.
   - С помощью `deriving (Read)` Haskell предоставляет функцию `read`, которая может взять строковое представление и преобразовать его обратно в значение типа `ATree`. Это полезно, если вы хотите сохранять и загружать данные в текстовом формате.




1. Функция `fringe`

fringe :: Tree a -> [a]
fringe (Leaf x) = [x]
fringe (Branch left right) = fringe left ++ fringe right

*Тип: `fringe` имеет тип `Tree a -> [a]`, что означает, что она принимает дерево и возвращает список значений того же типа, что и узлы дерева.

*Если дерево является листом (`Leaf x`), то функция возвращает список, содержащий единственное значение `x`.

*Если дерево является ветвью (`Branch left right`), функция рекурсивно вызывает `fringe` для левого и правого поддеревьев. Затем два списка значений объединяются с помощью оператора `++`.


!Эта функция, по сути, извлекает все значения из дерева в виде одномерного списка, следуя порядку, в котором посещаются все листья!



2. Функция `quantity`

height :: Tree a -> Int
height (Leaf _) = 1
height (Branch l r) = 1 + (max (height l) (height r))

*Тип: `height` имеет тип `Tree a -> Int`, что также означает, что она принимает дерево и возвращает целое число.

*Если дерево состоит из одного листа (`Leaf _`), функция возвращает 1, так как в дереве один элемент.

*Если дерево является ветвью (`Branch l r`), функция рекурсивно вызывает `quantity` для левого и правого поддеревьев, суммирует их результаты и добавляет 1 (за текущую ветвь).


!Эта функция подсчитывает общее количество узлов (листьев и ветвей) в дереве!



3. Функция `height`

height :: Tree a -> Int
height (Leaf _) = 1
height (Branch l r) = 1 + (max (height l) (height r))

*Тип: `height` имеет тип `Tree a -> Int`, что также означает, что она принимает дерево и возвращает целое число.

*Если дерево представляет собой лист (`Leaf _`), функция возвращает 1, указывая на то, что высота данного узла составляет 1.

*Если дерево является ветвью (`Branch l r`), функция рекурсивно вызывает `height` для левого и правого поддеревьев. Затем она вычисляет максимальную высоту между двумя поддеревьями и добавляет 1 (за текущую ветвь).

!Эта функция определяет высоту дерева, что представляет собой максимальное количество узлов от корня до самого глубокого листа!