МНОЖЕСТВА: 

Для представления конечных множеств в виде списков, есть ряд полезных функций, которые содержатся (помимо других полезных определений) в модуле Data.List.

*import Data.List

• nub xs — возвращает список, в котором удалены повторяющиеся элементы;

nub [1,2,3,4,3,2,1,2,4,3,5]
[1,2,3,4,5]

• delete x xs — удаляет первое вхождение заданного элемента x из списка xs;

delete True [True,False,True]
[False,True]

• union xs ys — возвращает объединение двух списков;

[1,2,2,2] `union` [2,2,3]
[1,2,2,2,3]

• intersect xs ys — возвращает пересечение двух списков;

[1,2,2,2] `intersect` [2,2,3]
[2,2,2]

• (\\) — возвращает разность (неассоциативную) двух списков, таким образом:
  (xs ++ ys) \\ xs == ys (если нет общих элементов);

[1,2,2,2] \\ [2,2,3]
[1,2]

• elem x xs — предикат, возвращающий истину, если элемент x принадлежит списку xs;

elem 2 [1,2]
True

elem 3 [1,2]
False

• tails xs – функция возвращает список хвостов данного списка, напр.:

tails [0,1,2]
[[0,1,2],[1,2],[2],[]]


СВЕРТКИ

сумма чисел в списке:

*Складываем про числа без свертки
total = sum array

Собственно, sum разворачивается в конструкцию вида:

sum = foldl (+) 0

*foldl(Fold Left) -  накапливая результат слева направо.

foldl (+) 0 [1, 2, 3] вычисляет сумму (1 + (2 + (3 + 0))) = 6.

и concat:

concat = foldr (++) []

Объединяет несколько списков в один список. ЗАМЕНЯЕТ СОБОЙ ARRAY

*foldr(Fold Right) -  накапливая результат справо налево.

foldr (+) 0 [1, 2, 3] вычисляет сумму (((0 + 1) + 2) + 3) = 6.

Реализация функции length` (длина списка) с помощью foldr:

length` :: [a] -> Int
length' xs = foldr (\_ acc -> acc + 1) 0 xs

*(\_ acc -> acc + 1) где:

_ - текущий элемент списка (не используется)

 acc - накопление значений

acc + 1 - возвращение накопленых значий с плюс 1

0 - это начальное значение аккумулятора

xs - список, который мы хотим свернуть

Подсчет суммы квадратов эментов списка:

sumSquares :: [Integer] -> Integer
sumSquares xs = foldr (\x acc -> x^2 + acc) 0 xs

*(\x acc -> x^2 + acc) где:

\x - лянда функция, которая принимает первый элемент списка

acc - накопление значений

x^2 + acc - возвращение накопленых значий у которой 

0 - это начальное значение аккумулятора

xs - список, который мы хотим свернуть



Посчитать сумму квадратов положительных элементов списка:

sumPosSquares :: [Integer] -> Integer
sumPosSquares xs = foldr (\x acc -> if x > 0
				    then x^2 + acc
				    else acc) 0 xs


*(\x acc -> if x > 0
	    then x^2 + acc
	    else acc) 0 xs где:

\x - лянда функция, которая принимает первый элемент списка

acc - накопление значений

if x > 0  - если значения списка 

0 - это начальное значение аккумулятора

xs - список, который мы хотим свернуть


Контрольная:
#1
f x = result
     where result = x^2 + 1

#2
Три правила хаскеля

#3
ничего не выводит, не определена first. А тогда была 6

#5
even - проверка на четность

#6
\x -> x `mod` 2 == 0

#7
x y -> if x>y
       then x
       else y

max x y

#8m     
x -> (x*2)*2

#10
overwite = x -> 

#