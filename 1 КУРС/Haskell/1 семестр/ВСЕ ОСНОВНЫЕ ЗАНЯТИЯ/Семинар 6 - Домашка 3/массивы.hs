-- №0
import Data.Array
arI :: Array (Int,Int) Int
arI = array ((1,1),(2,3)) [((1,1),8), ((1,2),11), ((1,3),4), ((2,1),3), ((2,2),2), ((2,3),4)]

-- №1 возвратить максимальный элемент; elems - вытаскивает из массива значения и переотправляет их в список
max :: Array (Int,Int) Int -> Int
max arr = maximum (elems arr)

-- №2 Суммировать элементы массива
sum1 :: Array (Int,Int) Int -> Int
sum1 arr = sum (elems arr)
sum' :: Array (Int,Int) Int -> Int
sum' arr = foldl (+) 0 (elems arr)

-- №3 суммирование элемнтов и прямой доступ к элементам
sum2 :: Array (Int,Int) Int -> Int
sum2 arr = sum [arr ! i | i <- indices arr]

-- №4 возвращение элементов массива, превышающих заданное значение

get :: Array (Int,Int) Int -> Int -> Int
get arr y  = sum [if x>y then 1 else 0 |x <- elems arr]

-- №4 Вывести список значений элементов, у которых сумма индексов равна значению
get2 :: Array (Int,Int) Int -> [Int]
get2 arr = [arr ! k | k <- indices arr, arr ! k == fst k + snd k]

-- arr ! k  - возвращает значение (элемент) массива по этому индексу
-- k <- indeces arr - k будет принимать значение каждого индекса массива, перебирая их из списка индексов.
-- arr ! k == fst k + snd k - берется  2 элемента массива (и возвращается его индексы) 
-- Оно проверяет, равно ли значение элемента массива, соответствующее индексу k, сумме его индексов.
-- То есть, элемент массива будет включен в результирующий список только в том случае, если его значение равно сумме индексов.


-- №5 Заменить значения элементов, у которых сумма индексов равна значению, на 77 (с помощью инкрементального обновления, функции (//)
get3 :: Int -> Array (Int,Int) Int -> Array (Int,Int) Int
get3 n arr = arr // [((i, j), 77) | (i, j) <- indices arr, i + j == n]

-- // - для обновления массива
-- ((i, j), 77) - создание списока пар, где (i,j) - индексы, для которых сумма i+j равно n
--indices arr - возвращает список индексов всех элементов массива.

-- №6 Реализовать функцию, которая возвращает новый массив, в котором каждый элемент является удвоенным значением элемента исходного массива.
get4 :: Array (Int,Int) Int -> Array (Int,Int) Int
get4 arr = array (bounds arr) [((i, j), 2 * (arr ! (i, j))) | (i, j) <- indices arr]

-- создание нового массива и bounds arr, который возвращает границы исходного массива (определяет мин и макс индекс массив)
-- indices arr возвращает список всех индексов (i, j) в двухмерном массиве arr

-- №7 Реализовать функцию, которая возвращает количество строк в массиве, где хотя бы один элемент больше заданного числа, используя any.
get5 :: Int -> Array (Int,Int) Int -> Int
get5 n arr = length [row | row <- [0..maxRow], any (> n) [arr !(i, j) | j <- [0..maxCol], let i = row]]
	where
    (start, (maxRow, maxCol)) = bounds arr
    arrRow i = [arr ! (i, j) | j <- [0..maxCol]]

-- length - считает количество строк, удовлетворяющих условию
-- row - для перебора всех индексов строк
-- row <- [0..maxRow] - генерация списка (с 0 до maxRow) и передаем в row, который теперь принимает значения с 0 до максимального
-- any (> n) - проверка на то что заданое n больше чем в строке
--  arr !(i, j) - для каждой строки мы создаем список значений
--  j <- [0..maxCol] -  генератор списка отвечает за создание списка столбцовых индексов (где  список целых чисел от 0 до maxCol (включительно))
-- let i = row - можно было использовать i в списковом выражении, которое строит список значений из массива arr по заданному индексу строки i и индексу столбца j (т.е. arr !(i, j))

-- *start не используется в дальньшем* 
-- (maxRow, maxCol) - получает значения максимальных индексов для строк и столбцов
-- arrRow i - Это определение вспомогательной функции, которая принимает индекс строки i и возвращает список значений этой строки в массиве arr
-- bounds arr - это функция, которая возвращает границы массива arr.


-- №8 вычислить длину пути ломанной, соединяющей точки в порядке возрастания нумерации в массиве.
-- Формула для расчета длины пути ломанной между двумя точками: sqrt((x2 - x1)^2 + (y2 - y1)^2)
brokenLine :: (Double, Double) -> (Double, Double) -> Double
brokenLine (x1,y1) (x2,y2) = sqrt((x2 - x1)^2 + (y2 - y1)^2)

-- возрастания нумерации в массиве
massivCoordinates :: Array (Double,Double) Int -> Double
massivCoordinates arr = sum [brokenLine sum [brokenLine (arr!i) (arr!(i + 1)) | i <- [0 .. (length (elems arr) - 2)]] 

-- (arr!i) и (arr!(i + 1) - индексация массива для получения пар координат
-- i <- [0 .. (length (elems arr) - 2)] -Этот список создает индексы от 0 до второго следущего индекса в массиве, что позволяет безопасно обращаться к следующему элементу массива внутри цикла.

-- №10 Для одномерного массива реализовать функцию, которая вычисляет произведение всех вторых элементов каждой пары в массиве.
-- massivPoint :: Array Int (Double, Double) -> Double
-- massivPoint arr = product [y | (_, y) <- elems arr]

-- product - вычисляет произведение чисел в списке
-- elems arr - возвращает список всех элементов массива (то есть всех пар(x, y), переобразует и выбирает второй элемент в массиве
-- parse error (possibly incorrect indentation or mismatched brackets)

-- №11 Напишите функцию change, которая разбивает переданную ей положительную сумму денег n на монеты достоинств из списка coins всеми возможными способами. Например, если coins = [2, 3, 7]

coinsmanetka :: Int -> [Int] -> [[Int]]
coinsmonetka 0 [] = [[]]
coinsmanetka [] = []
coinsmanetka n xs = 



