asect  0x00

#Реализация функци
#f(0) = 0
#f(n) = n + f(n-1)
#рекурсию сложения
	
main:
	
	addsp -2          # Уменьшение указателя стека на 2 для двух значений
    ldi r0, n        # Загрузка значения n в r0 для передачи в стек
    push r0          # Сохранение n по адресу стека
    jsr recursia     # Вызов функции рекурсии

    # После возврата, результат будет находиться в 0(sp)
    pop r1            # Загрузить результат из стека в r1
    ldi r0, result   # Подготовка адреса для сохранения результата
    st r0, r1        # Сохранение результата
    addsp 2          # Восстановление указателя стека
    halt
	
recursia:
	if
		tst r0 #Проверяет, равно ли значение в r0 нулю
	is nz #: Если r0 не равно нулю, выполняется блок кода в `if`
		addsp -1 # Резервируем место для возвращаемого значения
		push r0 #Сохраняет текущее значение r0 в стек
		dec r0 # Уменьшает значение  r0 на 1
		push r0 # Сохранить новое значение n на стек
		jsr recursia #Снова вызывает `recursia` с уменьшенным значением
		pop r0 #берет r0 из стека
		pop r1 # Загружаем результат из стека в r1
		add r1,r0 #Добавляет текущее значение r0 (которое равно n) к результату, который вернула рекурсивная функция, сохранившая его в r1 

	else
		clr r1
#Если r0 равно 0, то результат (факториал 0) устанавливается равным 1, а r1 обнуляется (при условии, что используется некорректная логика).
	fi
	addsp 1 # Восстановим указатель стека при выходе
	rts

INPUTS>
n:  dc 10

ENDINPUTS>
result: ds 1  
end
