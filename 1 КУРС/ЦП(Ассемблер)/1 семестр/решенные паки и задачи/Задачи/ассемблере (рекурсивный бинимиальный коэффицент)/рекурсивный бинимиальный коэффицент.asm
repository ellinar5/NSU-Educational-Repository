asect  0x00

#Реализация функци
#C(k,n)=C(k,n-1)+C(k-1,n-1)
#k<n
#C(0,m)=C(m,m)=1
#рекурсивный биномиальный коэффицент

#базовые случай:
#C(0,m)=1 (один способ выбрать 0 предметов)
#C(m,m)=1 (один способ выбрать все предметы)

 ldi r0,n           # Загрузка значения n
 ld r0,r0           # Загрузка значения n из памяти
 ldi r1,k           # Загрузка значения k
 ld r1,r1           # Загрузка значения k из памяти

 addsp -2           # Выделение места в стеке для аргументов
 push r0            # Сохранение n
 push r1            # Сохранение k
 jsr bin            # Вызов функции bin

 addsp 2            # Освобождение места в стеке
 pop r0             # Извлечение значения n из стека
 pop r1             # Извлечение значения k из стека

 st r0, res         # Сохранение результата n в res
 ldi r2, 1          # Загрузка значения 1
 add r2, r1         # Добавление 1 к результату k
 st r2, res         # Сохранение результата k в res

 wait
bin:

 ld r2, r1          # Загрузка значения k в r2
 add r2, 1          # Увеличиваем k на 1
 ld r0, r2          # Загружаем n в r2 для дальнейшей работы

 if
   tst r1           # Проверка, равно ли k нулю
 is z, or
   cmp r0,r1        # Сравнение n и k
 is eq               # Условие для C(0, n) или C(k, n)
  then
   ldi r0,1         # Сохранение итогового значения 1
   clr r1            # Очищаем r1

 else

   addsp -4          # Выделение места в стеке для аргументов
   dec r0            # Уменьшение n
   push r0           # Сохранение n
   push r1           # Сохранение k
   jsr bin           # Рекурсивный вызов bin
   ld r3, r2         # Получение результата из r2
   add r3, 1         # Увеличиваем результат на 1
   st r3, res        # Сохранение результата

   pop r1            # Восстановление k
   pop r0            # Восстановление n


    dec r1            # Уменьшение k


    push r0           # Сохранение n


    push r1           # Сохранение k


    


    jsr bin           # Снова вызываем bin


    


    addsp 4           # Освобождение 4 байт в стеке


    # Для замены popall, вместо него можно просто восстанавливать нужные регистры по отдельности.


    


    add r2, r0        # Сложение значений для результата


    add r3, r1        # Сохраняем новый результат в r3


  fi


  # Сохранение результата


  st r0, res         # Сохранение результата в память по адресу res


  


  rts                 # Возврат из функции


  


n: dc 7               # Значение n


k: dc 3               # Значение k


res: ds 2             # Резервируем место для результата


assembly

 Копировать код
end

 
INPUTS>  
n: dc 3
k: dc 3

ENDINPUTS>
res: ds 2
end
