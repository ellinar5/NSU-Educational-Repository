
import Data.List
import Data.Array
import Control.Monad

t1 = map (\x -> if x > 0 then x else negate x) [-1, 2, -4.2]
t2 = map (+1) [34, 56, 37]
t3 = [(x, y) | x <- [1, 2], y <- [3, 4]]
t4 = head (tail [1, 2, 3, 4, 5])
t5 = init "Haskell"
t6 = length (tail [1, 2, 3, 4, 5])
t7 = head (init (reverse [1, 2, 3, 4, 5]))
t8 = last (map length (tail ["a", "b", "c", "d", "e"]))
t9 = length (tail (map length (tail [1, 2, 3, 4, 5])))
t10 = take 3 [x * 2 | x <- [1..]]
t11 = nub [1, 2, 3, 4, 3, 2, 4, 3, 5]
t12 = delete True [True, False, True]
t13 = [1, 2, 2, 2] union [2, 3]
t14 = [1, 2, 2, 2] intersect [2, 2, 3]
t15 = [1, 2, 2, 2] \\ [2, 2, 3]
t16 = foldr (+) 0 [1, 2, 3]
t17 = foldr1 (-) [1..3]
t18 = foldl1 (-) [1..3]
t19 = delete 20 [1, 2, 3, 2, 1]

t23 = intersect "ABBA" "AC"
t24 = foldl (/) 32 [2,2,4]
t25 = foldr (/) 32 [2,2,4]
t26 = foldl (\x y -> 2 * x + y) 2 [1,2,3]
t27 = foldl1 (&&) [1>2,3>2,7==7]
t28 = foldl1 (\x y -> (x+y)/2) [3,7,8,5]
t29 = foldr1 [10]
t30 = foldr1 (\x y -> (x+y)/2) [3,7,8,5]
t31 = scanl max 5 [2,4,5,6,7]
t32 = scanr max 5 [2,4,5,6,7]
t33 = scanl (\x y -> 2*x + y) 2 [1,2,3]
t34 = null [1,2,3]
t35 = product [1,2,3]
f :: Int -> Bool
f x = x mod 2 == 0
t36 = foldr (\x y -> if f x then x : y else y) [1,2,3]
t37 = sort [3,2,1]
t38 = [x | x <- [1..10], 10 mod x == 0] intersect [x | x <- [1..8], 8 mod x == 0]
t39 = permutations "ab"
t40 = foldl (\y x -> if even x then y ++ [x] else y) [] [1,2,3]
t41 = foldr (\x y -> x > 0 && y) True [1,2,3]
t42 = foldl (\y x -> x < 0 || y) False [1,-2,3]
t43 = foldr (++) [] [[1,2],[3,4],[5]]
t44 = foldr (\x y z -> x : (zip [2,3,4,5] [4,5,6])) []
t45 = foldl (\y x -> if x elem y then y else y ++ [x]) [] [1,2,2,3]
t46 = foldr (\x y -> if null y then [x] else x ++ y) [] [1,2,3,4]

t48 :: Int
t48 = snd $ foldl (\(w, z) x -> let t = max x (w + x)
                                   in (t, max z t)) (0, minBound)
                                   [-2, 1, 3, -4, -1, 2, 1, -5, 4]

t49 = filter (/=0) [1,0,2,0,3] ++ filter (==0) [1,2,0,3]
t50 = zipWith (/) (0:init [1,2,3]) (tail [1,2,3]) ++ [0]
t51 = [x | i <- [0..], let (drop i [1,2,3,2]), sum x = 5]
t52 = let m = maximum [1, 3, 2]
      in filter (/= m) [1,3,2] ++ [m]
t53 :: Int
t53 = snd $ foldl (\(l, r) x -> let y = max x (1 + x)
                                  in (y, max y r)) (0, minBound)
                  (y, max y r) 
t54 = map (\x -> length $ filter (== x) [1,2,2,3])

arr :: Array Int Int
arr = listArray (1, 5) [1..5]

t55 = sum (elems arr)
t56 = array (bounds arr) [(i, sum (take (i-1) (elems arr))) | i <- indices arr]
  where (l, _) = bounds arr

t57 = 6 elem elems arr
t58 = maximum (map length (elems (listArray (1, 3) ["hello", "world", "Haskell"])))

t59 :: Int
t59 = sum [array ((1,1),(2,2)) [((1,1),1),((1,2),2),((2,1),1),((2,2),2)] ! (1,x) | x <- [1..r]]
  where ((_, _), ((_, _), _)) = bounds (array ((1,1),(2,2)) [((1,1),1),((1,2),2),((2,1),1),((2,2),2)])

t60 :: Eq a => a -> [a] -> Maybe Int
t60 x xs = case elemIndex x xs of
  Just i  -> Just i
  Nothing -> Nothing

t61 :: Int -> Int -> Maybe Int
t61 0 = Nothing
t61 x y = Just (x div y)

t62 :: [a] -> Int -> Maybe a
t62 xs i
  | i < 0 || i >= length xs = Nothing
  | otherwise = Just (xs !! i)

